#Strategy

Идеята му да имаме енкапсулирани алгоритми които си приличат по някакъв начин но са различни.
При него позлволяване на даден клас да има достъп до дадени алгоритми в зависимост от това от какво има нужда.
Трябва да помислил дали да не използваме strategy pattern-а когато имаме много if-ове или трябва да модифицираме класа.
Имаме някъв абстрактен клас, който има абстрактен метод (в него подаваме начина на имплементиране на метода)
Недостатъка на тази патерн е , че стратегиите не може да използват private членове.
Предимството е, че позволява много лесно да се пишат unit- тестове и методите да бъдат моквани.
Друго предимство е , че добавянето на нови стратегии (имплементации на абстрактния метод) не модифицират нищо старо.

#Chain of responsibility

Идеята му е при пускане на някаква заявка на даден клас и той  да знае какво да прави с нея,
и ако не е негова работа да го изпълни да я подаде на някой следваш, който да провери дали е ногова работа и така нататък.
С по-прости думи е верига от класове, които могат да изпълняват дадена работа и всеки прецеянва дали тази работа е за него 
(съответно дали да се заеме с нея или да я подаде някъде)
Това се изпозлва на много места и замества веригата от if-ове
Позволява ни да разделим някаква сложна логика за проверкаи на няколко отделни класа в които много по-лесно се намира ако има проблем и много по-лесно се добавя нещо ново.
Sender-а знае само за един изпълнител и всеки изпълнител знае само за следващия. Първия който свърши работата прекъсва веригата.
Използва се и при request-ти при web програмирането.

#Iterator

Идеята му е да ни позволи по някаккъв начин да обиколим дадена колекция коята не може да бъде обиколена по елементарен начин в езика.
Изключително полезен при работа с графи.
Скрива самото iter-иране.
Foreach е имплементиран iterator pattern.
Тук е важно да разделим самата структора от данни в отделен клас и логиката която я обикаля и итерира в отделен клас. 
Тоест имаме два отделни класа с различни задачи, първия дефинира как са структорирани данните, а втория дефинира как тези данни се обикалят,
и ако решим да сменим начина на итерация просто сменяме класа отговарящ за итерация с друг такъв и по -този начин няма никакъв проблем да използваме  дадена структура от данни с различни итератори.
Другия плюс е, че скрива всякакви сложности по имплементацията

#Template mehtod

Идеята му е, че той дефинира някакв алгоритъм в някакъв базов клас и оставя имплементацията на алгоритъма за неговите наследници. 
С други думи базовия клас само описва конкректните стъпки една след друга, но не каква как точно се изпълнява.
Тоест позволява ни да изпозваме наследяване когато искаме да изпозлваме даден алгоритъм.
Обикновенно това се изпълнява чрез абстрактни или виртуални методи и така трябва да се дефинира кода, че базовия клас да дефинира стъпките и тези под него да не могат да ги променят.
Използва се всеки път когато имаме един и същи алгоритъм с много малки промени.
Идеята е, че самия алгоръм не се променя, само конкретните имплементации се променят.


