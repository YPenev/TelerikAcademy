  1. Singleton pattern:

  Използва се за обекти, които трябва да бъдат глобално достъпни.
Позволява ни един клас да има единствена инстанция в цялата програма. 
Полезно е когато само един обект трябва да координира действия през системата.
Има много критики към него, дори някой го смятат за anti-design pattern, 
защото нарушава принципите на други desig pattern-и.
За да се подигурим, че обектът не може да бъде инстанциран от друго място, конструкторът се прави private. 
Когато ни потрябва за първи път извикваме статичен метод, който задейства конструктрра 
Singleton pattern се изпълнява, като се прави клас с метод, който прави нова инстанция на класа, ако не съществува.
Ако инстанцията съществува, връща референцията на този обект.
Трябва много да се внимава когато се използва в многонишкови приложения.
Ако две нишки се опитат да достъпят инсстанцията, може да се получи така, че в едно и също време да саздадът две инстанции на обекта.
Ако това се случи, най-вероятно втората инстаанция ще презапише първата и голяма част от данните ще се изгубят.
Друго важно нещо е, че инстанцията трябва да се създаде когато ни потрябва , а не в началото на приложението.
Най-добрия вариант за имплементиране на този патерн е с Lazy класа.
Голям минус е, че след използването на Singleton pattern кода става нетестваем.

  2. Object pool pattern:
  
    Позволява ни да създаваме обекти, които когато спрът да се изпозлват можем да ги изчистим,
 и вместо да ги изтрием, да ги подадем на следващия който има нужда от тях.
 С други думи веднъж създаваме нова инстанция на обекта и следващите пъти само го зачистваме и го преизпозлваме пак.
 Това може да става ръчно или автоматично.
 Object pool pattern-а е много полезен и може да предложи значително увеличение на производителността в ситуации,
 в които разходите за инициализиране на обект са високи (например когато работим с база данни,създаваме графичен обект или четем данните от интернет)
 а много по-лесно биха могли да бъдат използвани  повторно,  и всяка повторна употреба да спестява значително от времето за създаване.
 Когато няма свободни обекти, може да се създаде нов или ако работим с многонишкови операции - да се изчака някоя нишка да освободи обект.
 За да нямаме проблеми при изпозлването на този pattern, трябва да сме сигурни, че сме изчистили обекта напълно.
 
  3. Fluent interface pattern:
 Fluent interface е някаква добавка към вече написан код, която г оправи по-лесно разбираем и по-удобен.
 Спестява присвояванията на нови и нови променливи. В отделни случаи може да се представи като state машина.
 Той навързва методите верижно, като с това дава възможност на потребителя да лесно вижда до какво има достъп.
 Принципно контекста е задеден във връщаната стойност на метода, саморефериращ се когато искаме да продължим веригата
 и void тип когато искаме да е прекъснем.
 Примери за fluent interface са linq, ninject и др.
 IoStream библиотеката в C++ също е пример за една от първите имплементации на fluent interface.
